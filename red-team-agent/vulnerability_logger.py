"""Log vulnerability attempts to Supabase database"""
import os
import uuid
import json
from datetime import datetime, timezone
from typing import Optional, Dict, Any
from urllib.parse import urlparse
import requests
from config import Config


def get_session_id(ip_address: Optional[str] = None) -> str:
    """Generate a session ID from IP address and timestamp"""
    ip = ip_address or "red-team-agent"
    timestamp = int(datetime.now(timezone.utc).timestamp() * 1000)
    return f"{ip}_{timestamp}"


def get_technique_id(vulnerability_type: str) -> str:
    """Map vulnerability types to MITRE ATT&CK technique IDs"""
    technique_mapping = {
        'sql-injection-attempt': 'T1190',
        'sql-injection-suspicious': 'T1190',
        'sql-injection-normal': 'T1190',
        'xss-reflected': 'T1190',
        'xss-stored': 'T1190',
        'api-key-exposed': 'T1552',
        'authentication-bypass': 'T1078',
    }
    return technique_mapping.get(vulnerability_type, 'T1190')


def log_vulnerability_to_supabase(
    base_url: str,
    vulnerability_type: str,
    payload: Optional[str] = None,
    path: Optional[str] = None,
    success: Optional[bool] = None,
    additional_data: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Log a vulnerability attempt to Supabase vulnerability_logs table
    
    Args:
        base_url: The base URL of the target website
        vulnerability_type: Type of vulnerability (e.g., 'sql-injection-attempt')
        payload: The payload used in the attack (optional)
        path: The path/endpoint tested (optional)
        success: Whether the attack was successful (optional)
        additional_data: Additional fields to include in the log (optional)
    
    Returns:
        True if logging was successful, False otherwise
    """
    # Get Supabase configuration from environment
    supabase_url = os.getenv("SUPABASE_URL")
    supabase_service_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY")
    
    if not supabase_url or not supabase_service_key:
        print("[VulnerabilityLogger] Supabase not configured - skipping log. Set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in .env")
        return False
    
    # Extract origin from base_url
    parsed = urlparse(base_url)
    origin = f"{parsed.scheme}://{parsed.netloc}"
    
    # Get technique ID
    technique_id = get_technique_id(vulnerability_type)
    
    # Generate attacker_id and session_id
    attacker_id = "red-team-agent"
    session_id = get_session_id(attacker_id)
    
    # Helper function to sanitize strings for safe encoding
    def sanitize_string(s: str) -> str:
        """Sanitize string to ensure it's safe for JSON encoding"""
        if not isinstance(s, str):
            s = str(s)
        # Replace any problematic Unicode characters that can't be encoded in latin-1
        # This ensures the string can be safely serialized to JSON with ensure_ascii=True
        return s.encode('utf-8', errors='replace').decode('utf-8')
    
    # Build payload for Supabase - use only core required fields
    # Additional fields may be stored if the schema supports them
    log_payload = {
        "base_url": sanitize_string(origin),
        "vulnerability_type": sanitize_string(vulnerability_type),
        "technique_id": sanitize_string(technique_id),
        "attacker_id": sanitize_string(attacker_id),
        "session_id": sanitize_string(session_id),
    }
    
    # Add optional fields if schema supports them
    # These may be ignored if columns don't exist, but won't cause errors
    if path:
        log_payload["path"] = sanitize_string(path)
    
    if success is not None:
        log_payload["success"] = success
    
    # Add additional data (like sql_payload, vulnerable_query, etc.)
    # These will be included if the schema has JSONB columns or if they're actual columns
    if additional_data:
        # Only include fields that are likely to be supported
        # Store complex data in a way that won't break the insert
        for key, value in additional_data.items():
            # Convert complex types to strings if needed
            if isinstance(value, (list, dict)):
                # Sanitize the JSON string
                json_str = json.dumps(value, ensure_ascii=True)
                log_payload[key] = json_str
            elif isinstance(value, str):
                log_payload[key] = sanitize_string(value)
            else:
                log_payload[key] = sanitize_string(str(value))
    
    # Use Supabase REST API to insert
    try:
        # Construct the API endpoint - ensure URL is ASCII-safe
        api_url = f"{supabase_url}/rest/v1/vulnerability_logs"
        
        # Headers - service key should already be ASCII, don't modify it
        headers = {
            "apikey": supabase_service_key,
            "Authorization": f"Bearer {supabase_service_key}",
            "Content-Type": "application/json; charset=utf-8",
            "Prefer": "return=representation"
        }
        
        # All values in log_payload should already be sanitized
        # Double-check all string values are safe before sending
        encoded_payload = {}
        for key, value in log_payload.items():
            if value is None:
                encoded_payload[key] = None
            elif isinstance(value, bool):
                encoded_payload[key] = value
            elif isinstance(value, (int, float)):
                encoded_payload[key] = value
            elif isinstance(value, str):
                # Final sanitization pass - ensure ASCII-safe
                try:
                    # Test if it can be encoded as ASCII (which JSON with ensure_ascii=True will do)
                    value.encode('ascii')
                    encoded_payload[key] = value
                except UnicodeEncodeError:
                    # Force to ASCII by replacing non-ASCII characters
                    encoded_payload[key] = value.encode('ascii', errors='replace').decode('ascii')
            else:
                # Convert to string and sanitize
                str_val = str(value)
                try:
                    str_val.encode('ascii')
                    encoded_payload[key] = str_val
                except UnicodeEncodeError:
                    encoded_payload[key] = str_val.encode('ascii', errors='replace').decode('ascii')
        
        # Final sanitization: ensure ALL string values are pure ASCII
        final_payload = {}
        for k, v in encoded_payload.items():
            if isinstance(v, str):
                # Force to pure ASCII by replacing any non-ASCII characters
                final_payload[k] = v.encode('ascii', errors='replace').decode('ascii')
            elif v is None:
                final_payload[k] = None
            elif isinstance(v, bool):
                final_payload[k] = v
            elif isinstance(v, (int, float)):
                final_payload[k] = v
            else:
                # Convert to string and force ASCII
                final_payload[k] = str(v).encode('ascii', errors='replace').decode('ascii')
        
        # Use json parameter - requests will handle encoding correctly if data is clean
        response = requests.post(
            api_url,
            json=final_payload,  # Use json parameter for automatic encoding
            headers=headers,
            timeout=10
        )
        
        if response.status_code in [200, 201]:
            print(f"[VulnerabilityLogger] Successfully logged {vulnerability_type} to Supabase")
            return True
        else:
            # Safely extract error message
            try:
                error_text = response.text[:200] if hasattr(response, 'text') else 'No error text'
            except:
                error_text = 'Could not read error'
            print(f"[VulnerabilityLogger] Failed: HTTP {response.status_code} - {error_text}")
            return False
            
    except (UnicodeEncodeError, UnicodeDecodeError) as e:
        # Encoding error - force all data to ASCII and retry
        try:
            # Force all string values to pure ASCII
            ascii_payload = {}
            for key, value in final_payload.items():
                if isinstance(value, str):
                    ascii_payload[key] = value.encode('ascii', errors='replace').decode('ascii')
                else:
                    ascii_payload[key] = value
            
            # Retry with ASCII-only payload using json parameter
            response = requests.post(
                api_url,
                json=ascii_payload,
                headers=headers,
                timeout=10
            )
            if response.status_code in [200, 201]:
                print(f"[VulnerabilityLogger] Successfully logged {vulnerability_type} to Supabase")
                return True
            else:
                error_msg = response.text[:100] if hasattr(response, 'text') else str(response.status_code)
                print(f"[VulnerabilityLogger] Failed: {response.status_code} - {error_msg}")
                return False
        except Exception:
            # If retry also fails, just return False without printing (to avoid encoding issues)
            return False
    except Exception as e:
        import traceback
        print(f"[VulnerabilityLogger] Exception while logging to Supabase: {e}")
        print(f"[VulnerabilityLogger] Traceback: {traceback.format_exc()}")
        return False


def log_sql_injection_attempt(
    url: str,
    payload: str,
    method: str,
    parameter: Optional[str] = None,
    success: bool = False,
    response_indicators: Optional[list] = None
) -> bool:
    """
    Log a SQL injection attempt to Supabase
    
    Args:
        url: The URL that was tested
        payload: The SQL injection payload used
        method: HTTP method used (GET, POST, etc.)
        parameter: The parameter name that was tested (optional)
        success: Whether the injection was successful
        response_indicators: List of indicators found in response (optional)
    
    Returns:
        True if logging was successful, False otherwise
    """
    parsed = urlparse(url)
    path = parsed.path or None
    
    # Determine vulnerability type based on success
    if success:
        vulnerability_type = "sql-injection-attempt"
    else:
        # Could be suspicious or just a test attempt
        vulnerability_type = "sql-injection-attempt"  # Log all attempts
    
    # Build additional data
    additional_data = {
        "sql_payload": payload,
    }
    
    if parameter:
        additional_data["parameter"] = parameter
    
    if method:
        additional_data["http_method"] = method
    
    if response_indicators:
        additional_data["response_indicators"] = ", ".join(response_indicators)
    
    # Construct vulnerable query for logging
    # Use ASCII quotes to avoid encoding issues
    if parameter:
        # Ensure payload is ASCII-safe before using in query
        safe_payload = payload.encode('ascii', errors='replace').decode('ascii')
        safe_param = parameter.encode('ascii', errors='replace').decode('ascii')
        vulnerable_query = f"SELECT * FROM users WHERE {safe_param} = '{safe_payload}'"
        additional_data["vulnerable_query"] = vulnerable_query
    
    return log_vulnerability_to_supabase(
        base_url=url,
        vulnerability_type=vulnerability_type,
        payload=payload,
        path=path,
        success=success,
        additional_data=additional_data
    )

